Intructions:

- Each player has 20 starting hitpoints. 
- Keep hitpoints as a serverside resource like parameter (but don't add it to resources). 
- When a players hitpoints drop to 0, they lose the game. 

- We're going to add creeps. Lets start with 2 types of creeps: ghosts and trolls.

# Ghosts 
- id: GHOST 
- Speed: 30 
- Hitpoints: 50 
- Damage: 1 

# Trolls 
- id: TROLL
- Speed: 25 
- Hitpoints: 250 
- Damage: 2

Creeps will be spawned in waves at certain ticks.
Check /src/main/resources/levels/0001.waves and make an interpreter for the format. 
Each level (we currently only have 0001.level) will have a corresponding .waves file (0001.waves), so make sure it loads correctly. 
-> so the "level" is "0001" and it has a .level file and a .waves file. 

- Creeps also hold their position data.
- Creeps will be spawned at each spawner ingame, and follow the road to the castle. their starting location is the center of the spawner. 
- Moving creeps happens every tick at serverside. They move at ((10 / speed)) tiles per second. Their position gets updated and an UpdateCreepCommand is sent
- When they reach a castle, they disappear (DespawnCreepCommand) and deal {damage} damage to the player that owns the castle they reach. 

- All logic is serverside

use following commands
- SpawnCreepCommand (ServerToClientCommand) 
    creep data 
    spawner data
- UpdateCreepCommand (ServerToClientCommand) 
    creep data 
- DespawnCreepCommand (ServerToClientCommand) 
    creep data 
- PlayerTakesDamageCommand (ServerToClientCommand)
    player 
    damage 
    remainingHP 

these commands are currently sent to all players, as every player can see the whole map and should get appropriate updates.

---

# Implementation Plan

## Overview

This feature adds a wave-based creep spawning system where:
- Creeps spawn at spawners and walk along roads to the castle
- When creeps reach the castle, they deal damage to the owning player
- Players lose when their HP reaches 0

## Phase 1: Player Hitpoints

### Files to Create/Modify:
- `Turrest01Player.java` - Add `hitpoints` field (default: 20)

### Implementation:
```java
// In Turrest01Player.java
private int hitpoints = 20;

public int getHitpoints() { return hitpoints; }
public void takeDamage(int damage) {
    hitpoints = Math.max(0, hitpoints - damage);
}
public boolean isAlive() { return hitpoints > 0; }
```

---

## Phase 2: Creep Type Definitions

### Files to Create:
- `src/main/java/be/lefief/game/turrest01/creep/CreepType.java` - Enum with GHOST and TROLL

### Implementation:
```java
public enum CreepType {
    GHOST("GHOST", 30, 50, 1),   // speed 30, hp 50, damage 1
    TROLL("TROLL", 25, 250, 2);  // speed 25, hp 250, damage 2

    private final String id;
    private final int speed;
    private final int hitpoints;
    private final int damage;

    // Constructor, getters

    public static CreepType fromId(String id) {
        for (CreepType type : values()) {
            if (type.id.equals(id)) return type;
        }
        return null;
    }
}
```

---

## Phase 3: Creep Entity

### Files to Create:
- `src/main/java/be/lefief/game/turrest01/creep/Creep.java`

### Implementation:
```java
public class Creep {
    private final UUID id;
    private final CreepType type;
    private final int ownerPlayerNumber;  // Which player's territory this creep is in
    private double x, y;                  // Position (can be fractional for smooth movement)
    private int currentPathIndex;         // Index in the path list
    private final List<Point> path;       // Pre-computed path from spawner to castle
    private int hitpoints;

    // Constructor, getters, movement logic

    public void move(double deltaTime) {
        // Move toward next path point
        // Speed formula: (10 / speed) tiles per second
        double tilesPerSecond = 10.0 / type.getSpeed();
        // ... movement logic
    }

    public boolean hasReachedCastle() {
        return currentPathIndex >= path.size();
    }
}
```

---

## Phase 4: Wave Loader

### Files to Create:
- `src/main/java/be/lefief/game/turrest01/wave/WaveLoader.java`
- `src/main/java/be/lefief/game/turrest01/wave/Wave.java`

### Wave Format:
```
30: GHOST, GHOST, GHOST
90: GHOST, GHOST, GHOST, GHOST, GHOST
```
- `tick: CREEP_TYPE, CREEP_TYPE, ...`

### Implementation:
```java
public class Wave {
    private final int tick;
    private final List<CreepType> creeps;
}

public class WaveLoader {
    public static List<Wave> load(String levelName) throws IOException {
        // Load from "levels/{levelName}.waves"
        // Parse format: "tick: TYPE, TYPE, TYPE"
        List<Wave> waves = new ArrayList<>();
        // ... parsing logic
        return waves;
    }
}
```

---

## Phase 5: Creep Manager

### Files to Create:
- `src/main/java/be/lefief/game/turrest01/creep/CreepManager.java`

### Responsibilities:
1. Track all active creeps per player
2. Spawn creeps from waves at the correct tick
3. Move creeps each tick
4. Detect when creeps reach castle and deal damage
5. Remove dead/despawned creeps

### Implementation:
```java
public class CreepManager {
    private final Map<UUID, Creep> activeCreeps = new ConcurrentHashMap<>();
    private final List<Wave> waves;
    private final Map<Integer, List<Point>> playerPaths; // playerNumber -> path from spawner to castle

    public CreepManager(List<Wave> waves, GameMap gameMap) {
        this.waves = waves;
        this.playerPaths = computePathsForAllPlayers(gameMap);
    }

    public void tick(int currentTick, TurrestGameMode01 game) {
        // 1. Check if any wave should spawn
        spawnWaveCreeps(currentTick, game);

        // 2. Move all creeps
        moveCreeps(game);

        // 3. Check for creeps reaching castle
        checkCastleReached(game);
    }

    private void spawnWaveCreeps(int tick, TurrestGameMode01 game) {
        for (Wave wave : waves) {
            if (wave.getTick() == tick) {
                // Spawn creeps for each player (each player has their own spawner)
                for (int playerNum = 0; playerNum < game.getPlayerCount(); playerNum++) {
                    for (CreepType type : wave.getCreeps()) {
                        Creep creep = new Creep(type, playerNum, playerPaths.get(playerNum));
                        activeCreeps.put(creep.getId(), creep);
                        game.broadcastToAllPlayers(new SpawnCreepCommand(creep, playerNum));
                    }
                }
            }
        }
    }

    private void moveCreeps(TurrestGameMode01 game) {
        for (Creep creep : activeCreeps.values()) {
            creep.move(1.0); // 1 second per tick
            game.broadcastToAllPlayers(new UpdateCreepCommand(creep));
        }
    }

    private void checkCastleReached(TurrestGameMode01 game) {
        Iterator<Map.Entry<UUID, Creep>> it = activeCreeps.entrySet().iterator();
        while (it.hasNext()) {
            Creep creep = it.next().getValue();
            if (creep.hasReachedCastle()) {
                // Deal damage to player
                Turrest01Player player = game.getPlayerByNumber().get(creep.getOwnerPlayerNumber());
                player.takeDamage(creep.getType().getDamage());

                // Broadcast commands
                game.broadcastToAllPlayers(new DespawnCreepCommand(creep));
                game.broadcastToAllPlayers(new PlayerTakesDamageCommand(
                    creep.getOwnerPlayerNumber(),
                    creep.getType().getDamage(),
                    player.getHitpoints()
                ));

                // Check for game over
                if (!player.isAlive()) {
                    game.handlePlayerDeath(player);
                }

                it.remove();
            }
        }
    }
}
```

---

## Phase 6: Path Computation

### Approach:
The roads are already generated using BFS/random-walk from spawner to castle. We need to:
1. Store the ordered path (not just positions) during road generation
2. OR recompute the path at game start using BFS on road tiles

### Recommended: Recompute paths at game start
- Use BFS from each player's spawner following road tiles to castle
- Store as `List<Point>` for each player

### Files to Modify:
- `RoadGenerator.java` - Add method to return ordered path, not just set
- OR create `PathFinder.java` to compute path from roads at runtime

---

## Phase 7: Server Commands

### Files to Create:
- `src/main/java/be/lefief/game/turrest01/commands/SpawnCreepCommand.java`
- `src/main/java/be/lefief/game/turrest01/commands/UpdateCreepCommand.java`
- `src/main/java/be/lefief/game/turrest01/commands/DespawnCreepCommand.java`
- `src/main/java/be/lefief/game/turrest01/commands/PlayerTakesDamageCommand.java`

### Data Structure:
```java
// SpawnCreepCommand
{
    creepId: UUID,
    creepType: "GHOST" | "TROLL",
    x: double,
    y: double,
    playerNumber: int  // Which player's territory
}

// UpdateCreepCommand
{
    creepId: UUID,
    x: double,
    y: double
}

// DespawnCreepCommand
{
    creepId: UUID
}

// PlayerTakesDamageCommand
{
    playerNumber: int,
    damage: int,
    remainingHitpoints: int
}
```

---

## Phase 8: Game Loop Integration

### Files to Modify:
- `TurrestGameMode01.java`

### Changes:
1. Load waves during `start()`
2. Create `CreepManager`
3. Call `creepManager.tick(tickCount, this)` in `gameTick()`
4. Add `handlePlayerDeath()` method

---

## Phase 9: Frontend Updates

### Files to Create/Modify:
- `frontend/src/app/shared/models/creep.model.ts` - Creep interface
- `frontend/src/app/features/game/game.component.ts` - Handle creep commands, render creeps

### Frontend Implementation:
```typescript
// creep.model.ts
export interface Creep {
    id: string;
    type: 'GHOST' | 'TROLL';
    x: number;
    y: number;
    playerNumber: number;
}

// game.component.ts
creeps: Map<string, Creep> = new Map();

// Subscribe to commands:
// SPAWN_CREEP -> add to creeps map
// UPDATE_CREEP -> update position in map
// DESPAWN_CREEP -> remove from map
// PLAYER_TAKES_DAMAGE -> update UI (show HP bar, flash screen, etc.)

// In render():
// Draw each creep as a sprite/icon at their position
```

---

## Implementation Order

1. **Phase 2: CreepType enum** - Define creep stats
2. **Phase 4: WaveLoader** - Parse .waves files
3. **Phase 3: Creep entity** - Creep class with position and movement
4. **Phase 6: Path computation** - Compute spawner-to-castle paths
5. **Phase 1: Player hitpoints** - Add HP to players
6. **Phase 7: Commands** - Create all 4 command classes
7. **Phase 5: CreepManager** - Core wave/creep logic
8. **Phase 8: Game loop** - Integrate into TurrestGameMode01
9. **Phase 9: Frontend** - Render creeps and HP

---

## Testing Checklist

- [ ] Waves load correctly from .waves file
- [ ] Creeps spawn at correct tick at each player's spawner
- [ ] Creeps move along roads toward castle
- [ ] Movement speed matches formula: (10/speed) tiles/second
- [ ] Creeps despawn when reaching castle
- [ ] Player takes correct damage when creep reaches castle
- [ ] Player death triggers game over
- [ ] All players see all creeps on all territories
- [ ] Frontend renders creeps correctly
- [ ] HP bar/display shows remaining hitpoints