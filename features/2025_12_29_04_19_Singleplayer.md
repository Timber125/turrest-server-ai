Instruction: 

- Allow singleplayer
- Add testing capabilities (and supporting code) so that we can simulate a game "as fast as possible" instead of via timed ticks.

This will allow rapidly testing strategies in the future.

---

## Implementation Plan (Revised)

### Design Principles Applied

1. **Interface Segregation**: Use `SimulatableGame` interface instead of polluting production code with simulation flags
2. **Time-Based Scheduling**: Use game time (seconds) instead of tick numbers for more intuitive action scheduling
3. **Immutable Game State**: Read-only `GameStateSnapshot` for strategies prevents accidental mutations
4. **Command Pattern**: Unified `GameAction` interface works for both simulation and potential replays
5. **Dependency Injection**: Simulator receives game factory, not concrete class
6. **Deterministic Simulation**: Support for seeded randomness enables reproducible results

---

### Current Architecture

**Game Creation Flow:**
1. User creates lobby via `LobbyService.createLobby()`
2. Host starts game via `LobbyService.startGame()`
3. `GameService.createGame()` creates `TurrestGameMode01` instance
4. Game requires `List<ClientSession>` players - minimum 1

**Game Loop (TurrestGameMode01.java):**
```java
private static final int TICK_RATE_MS = 200; // 5 Hz
gameLoop.scheduleAtFixedRate(this::gameTick, TICK_RATE_MS, TICK_RATE_MS, TimeUnit.MILLISECONDS);
```

**Wave System:**
- Waves spawn based on tick number: `if (wave.getTick() == tick)`
- CreepManager.tick() processes spawning, movement, castle checks
- TowerManager.tick() processes targeting and attacks

**Current Limitations:**
- No single-player mode (lobby requires opponents)
- Game runs in real-time only (no fast-forward)
- Cannot programmatically control player actions for testing

---

### Part 1: Singleplayer Mode

#### 1.1 Frontend: Skip Lobby for Singleplayer

**Modify: `lobby-list.component.ts`**

Add "Play Solo" button that directly starts a singleplayer game:

```typescript
template: `
  ...
  <button class="solo-btn" (click)="startSingleplayer()">
    Play Solo
  </button>
`

startSingleplayer(): void {
  this.lobbyService.startSingleplayerGame();
  this.router.navigate(['/game']);
}
```

**Modify: `lobby.service.ts`**

```typescript
startSingleplayerGame(): void {
  this.socketService.sendCommand('LOBBY', 'START_SINGLEPLAYER', {
    game: 'turrest01'
  });
  this.isInGame.set(true);
}
```

#### 1.2 Backend: Singleplayer Game Creation

**New File: `StartSingleplayerCommand.java`**

```java
public class StartSingleplayerCommand extends ClientToServerCommand {
    public static final ServerSocketSubject SUBJECT = ServerSocketSubject.LOBBY;
    public static final String TOPIC = "START_SINGLEPLAYER";

    public String getGame() {
        return (String) data.get("game");
    }
}
```

**New File: `StartSingleplayerHandler.java`**

```java
@Component
public class StartSingleplayerHandler extends CommandHandler<StartSingleplayerCommand> {
    private final GameService gameService;

    @Override
    public void accept(SecuredClientToServerCommand<StartSingleplayerCommand> command,
                       ClientSession clientSession) {
        // Create single-player game directly (no lobby needed)
        gameService.createSingleplayerGame(
            clientSession,
            command.getCommand().getGame()
        );
    }
}
```

**Modify: `GameService.java`**

```java
public void createSingleplayerGame(ClientSession player, String gameType) {
    UUID gameId = UUID.randomUUID();

    // Create game with single player
    List<ClientSession> players = List.of(player);
    Map<UUID, Integer> colorMap = Map.of(player.getUserId(), 0);

    TurrestGameMode01 game = new TurrestGameMode01(players, player.getUserId(), colorMap);
    game.setSingleplayer(true);  // Enable singleplayer mode

    games.put(gameId, game);
    playerActiveGame.put(player.getUserId(), gameId);

    game.start();
}
```

#### 1.3 Backend: Singleplayer Wave Adjustments

**Modify: `TurrestGameMode01.java`**

```java
private boolean singleplayer = false;

public void setSingleplayer(boolean singleplayer) {
    this.singleplayer = singleplayer;
}

public boolean isSingleplayer() {
    return singleplayer;
}
```

**Modify: `CreepManager.java`**

In singleplayer, waves still spawn but no player-sent creeps affect you:

```java
// spawnSentCreep() - only spawn if more than 1 player
public void spawnSentCreep(CreepType type, int senderPlayerNumber, TurrestGameMode01 game) {
    if (playerCount <= 1) {
        // Singleplayer: No opponents to send to
        return;
    }
    // ... existing logic
}
```

#### 1.4 Win Condition for Singleplayer

**Modify: `TurrestGameMode01.java`**

Singleplayer win condition: Survive all waves

```java
private void checkSingleplayerVictory() {
    if (!singleplayer) return;

    // Check if all waves have spawned and all creeps are dead
    boolean allWavesComplete = tickCount > getLastWaveTick();
    boolean noActiveCreeps = creepManager.getActiveCreepCount() == 0;

    if (allWavesComplete && noActiveCreeps) {
        Turrest01Player player = getPlayerByNumber().get(0);
        if (player != null && player.isAlive()) {
            broadcastToAllPlayers(new GameOverCommand(0, true));
            stop();
        }
    }
}

private int getLastWaveTick() {
    // Return the tick of the last wave
    return waves.stream()
        .mapToInt(Wave::getTick)
        .max()
        .orElse(0);
}
```

---

### Part 2: Simulation Architecture

#### 2.1 SimulatableGame Interface

Instead of adding simulation flags to production code, define a clean interface:

**New File: `src/main/java/be/lefief/game/core/simulation/SimulatableGame.java`**

```java
package be.lefief.game.core.simulation;

/**
 * Interface for games that can be run in simulation mode.
 * Separates simulation concerns from network/UI concerns.
 */
public interface SimulatableGame {

    /**
     * Process one game tick with the given delta time.
     * @param deltaTimeSeconds Time since last tick in seconds
     */
    void processTick(double deltaTimeSeconds);

    /**
     * Get current game time in seconds since start.
     */
    double getGameTimeSeconds();

    /**
     * Check if game is still running (not ended).
     */
    boolean isRunning();

    /**
     * Create a read-only snapshot of current game state.
     */
    GameStateSnapshot createSnapshot();

    /**
     * Execute a game action directly (bypasses network).
     */
    ActionResult executeAction(GameAction action);
}
```

#### 2.2 Immutable Game State Snapshot

**New File: `src/main/java/be/lefief/game/core/simulation/GameStateSnapshot.java`**

```java
package be.lefief.game.core.simulation;

import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Immutable snapshot of game state for strategy decision-making.
 * All collections are unmodifiable to prevent accidental mutation.
 */
public interface GameStateSnapshot {

    // Time
    double getGameTimeSeconds();
    int getCurrentTick();

    // Players
    int getPlayerCount();
    PlayerSnapshot getPlayer(int playerNumber);
    List<PlayerSnapshot> getAllPlayers();

    // Map
    int getMapWidth();
    int getMapHeight();
    TileSnapshot getTile(int x, int y);

    // Entities
    List<CreepSnapshot> getCreeps();
    List<CreepSnapshot> getCreepsForPlayer(int playerNumber);
    List<TowerSnapshot> getTowers();
    List<TowerSnapshot> getTowersForPlayer(int playerNumber);

    // Utility methods for strategies
    boolean canAfford(int playerNumber, ResourceCost cost);
    List<TileSnapshot> getBuildableTiles(int playerNumber);
    Optional<TileSnapshot> findNearestEmptyTileToPath(int playerNumber);
}

/**
 * Immutable player state snapshot.
 */
public record PlayerSnapshot(
    int playerNumber,
    int colorIndex,
    boolean alive,
    int hitpoints,
    int gold,
    int wood,
    int stone,
    int score
) {}

/**
 * Immutable tile state snapshot.
 */
public record TileSnapshot(
    int x,
    int y,
    String terrainType,
    boolean hasStructure,
    String structureType,  // null if no structure
    int ownerPlayerNumber  // -1 if neutral
) {}

/**
 * Immutable creep state snapshot.
 */
public record CreepSnapshot(
    int id,
    String typeId,
    int ownerPlayerNumber,
    int targetPlayerNumber,
    double x,
    double y,
    int currentHp,
    int maxHp
) {}

/**
 * Immutable tower state snapshot.
 */
public record TowerSnapshot(
    int id,
    String typeId,
    int ownerPlayerNumber,
    int x,
    int y,
    double range,
    int damage
) {}
```

#### 2.3 Unified Game Action Interface

**New File: `src/main/java/be/lefief/game/core/simulation/GameAction.java`**

```java
package be.lefief.game.core.simulation;

/**
 * Command pattern for game actions.
 * Works for both simulation and potential replay systems.
 */
public interface GameAction {
    /**
     * Player number performing the action.
     */
    int getPlayerNumber();

    /**
     * Unique action type identifier.
     */
    String getActionType();
}

/**
 * Result of executing an action.
 */
public record ActionResult(
    boolean success,
    String errorMessage  // null if success
) {
    public static ActionResult success() {
        return new ActionResult(true, null);
    }

    public static ActionResult failure(String reason) {
        return new ActionResult(false, reason);
    }
}
```

**New File: `src/main/java/be/lefief/game/turrest01/simulation/TurrestActions.java`**

```java
package be.lefief.game.turrest01.simulation;

import be.lefief.game.core.simulation.GameAction;

/**
 * Turrest-specific game actions.
 */
public sealed interface TurrestAction extends GameAction
    permits PlaceBuildingAction, PlaceTowerAction, SendCreepAction {
}

public record PlaceBuildingAction(
    int playerNumber,
    int x,
    int y,
    int buildingTypeId
) implements TurrestAction {
    @Override
    public String getActionType() { return "PLACE_BUILDING"; }
}

public record PlaceTowerAction(
    int playerNumber,
    int x,
    int y,
    int towerTypeId
) implements TurrestAction {
    @Override
    public String getActionType() { return "PLACE_TOWER"; }
}

public record SendCreepAction(
    int playerNumber,
    String creepTypeId
) implements TurrestAction {
    @Override
    public String getActionType() { return "SEND_CREEP"; }
}
```

---

### Part 3: Simulation Engine

#### 3.1 Time-Based Simulator

**New File: `src/main/java/be/lefief/game/core/simulation/GameSimulator.java`**

```java
package be.lefief.game.core.simulation;

import java.util.*;
import java.util.function.Supplier;

/**
 * Fast simulation engine for any SimulatableGame.
 * Uses game time (seconds) instead of tick numbers for scheduling.
 */
public class GameSimulator<G extends SimulatableGame> {

    private final G game;
    private final double tickDurationSeconds;

    // Actions scheduled by game time
    private final TreeMap<Double, List<GameAction>> scheduledActions = new TreeMap<>();

    // Optional strategies for automated play
    private final Map<Integer, Strategy> playerStrategies = new HashMap<>();

    public GameSimulator(G game, double tickDurationSeconds) {
        this.game = game;
        this.tickDurationSeconds = tickDurationSeconds;
    }

    /**
     * Factory method for creating simulator with game supplier.
     * Enables dependency injection of game creation.
     */
    public static <G extends SimulatableGame> GameSimulator<G> create(
            Supplier<G> gameFactory,
            double tickDurationSeconds) {
        return new GameSimulator<>(gameFactory.get(), tickDurationSeconds);
    }

    /**
     * Schedule action at specific game time (in seconds).
     * More intuitive than tick-based scheduling.
     */
    public void scheduleAction(double gameTimeSeconds, GameAction action) {
        scheduledActions
            .computeIfAbsent(gameTimeSeconds, k -> new ArrayList<>())
            .add(action);
    }

    /**
     * Assign a strategy to control a player.
     */
    public void setStrategy(int playerNumber, Strategy strategy) {
        playerStrategies.put(playerNumber, strategy);
    }

    /**
     * Run simulation for specified duration.
     * @param durationSeconds Maximum game time to simulate
     * @return Simulation results
     */
    public SimulationResult run(double durationSeconds) {
        long startRealTime = System.nanoTime();
        int ticksProcessed = 0;

        while (game.isRunning() && game.getGameTimeSeconds() < durationSeconds) {
            double currentTime = game.getGameTimeSeconds();

            // Execute scheduled actions for current time
            executeScheduledActions(currentTime);

            // Let strategies decide actions
            executeStrategyActions();

            // Process one tick
            game.processTick(tickDurationSeconds);
            ticksProcessed++;
        }

        long endRealTime = System.nanoTime();
        double realTimeMs = (endRealTime - startRealTime) / 1_000_000.0;

        return new SimulationResult(
            ticksProcessed,
            game.getGameTimeSeconds(),
            realTimeMs,
            game.createSnapshot()
        );
    }

    private void executeScheduledActions(double currentTime) {
        // Get all actions scheduled up to current time
        var actionsToExecute = scheduledActions.headMap(currentTime, true);

        for (var entry : actionsToExecute.entrySet()) {
            for (GameAction action : entry.getValue()) {
                game.executeAction(action);
            }
        }

        // Remove executed actions
        actionsToExecute.clear();
    }

    private void executeStrategyActions() {
        if (playerStrategies.isEmpty()) return;

        GameStateSnapshot snapshot = game.createSnapshot();

        for (var entry : playerStrategies.entrySet()) {
            int playerNumber = entry.getKey();
            Strategy strategy = entry.getValue();

            Optional<GameAction> action = strategy.decide(snapshot, playerNumber);
            action.ifPresent(game::executeAction);
        }
    }

    /**
     * Get underlying game for direct access.
     */
    public G getGame() {
        return game;
    }
}
```

#### 3.2 Simulation Result

**New File: `src/main/java/be/lefief/game/core/simulation/SimulationResult.java`**

```java
package be.lefief.game.core.simulation;

/**
 * Results of a simulation run.
 */
public record SimulationResult(
    int ticksProcessed,
    double gameTimeSeconds,
    double realTimeMs,
    GameStateSnapshot finalState
) {

    /**
     * Calculate simulation speed multiplier.
     * e.g., 2000x means simulation ran 2000 times faster than real-time.
     */
    public double getSpeedMultiplier() {
        if (realTimeMs == 0) return Double.MAX_VALUE;
        double gameTimeMs = gameTimeSeconds * 1000;
        return gameTimeMs / realTimeMs;
    }

    /**
     * Check if a specific player won.
     */
    public boolean playerWon(int playerNumber) {
        PlayerSnapshot player = finalState.getPlayer(playerNumber);
        if (player == null || !player.alive()) return false;

        // Winner is last player standing
        return finalState.getAllPlayers().stream()
            .filter(p -> p.playerNumber() != playerNumber)
            .noneMatch(PlayerSnapshot::alive);
    }

    /**
     * Check if game ended in a draw (no winner).
     */
    public boolean isDraw() {
        long alivePlayers = finalState.getAllPlayers().stream()
            .filter(PlayerSnapshot::alive)
            .count();
        return alivePlayers != 1;
    }
}
```

---

### Part 4: Strategy Framework

#### 4.1 Strategy Interface

**New File: `src/main/java/be/lefief/game/core/simulation/Strategy.java`**

```java
package be.lefief.game.core.simulation;

import java.util.Optional;

/**
 * Interface for AI strategies that control players in simulation.
 *
 * Design decisions:
 * - Returns Optional<GameAction> instead of List to enforce one action per tick
 * - Receives immutable snapshot to prevent accidental state mutation
 * - Stateless by default (implement StatefulStrategy for complex strategies)
 */
@FunctionalInterface
public interface Strategy {
    /**
     * Decide what action to take, if any.
     *
     * @param state Current game state (immutable snapshot)
     * @param playerNumber The player this strategy controls
     * @return Action to execute, or empty if no action this tick
     */
    Optional<GameAction> decide(GameStateSnapshot state, int playerNumber);
}

/**
 * Strategy that maintains state between decisions.
 * Useful for strategies that need memory (e.g., build order tracking).
 */
public interface StatefulStrategy extends Strategy {
    /**
     * Reset strategy state for a new game.
     */
    void reset();

    /**
     * Called when game ends, for cleanup or learning.
     */
    default void onGameEnd(SimulationResult result) {}
}
```

#### 4.2 Example Strategies

**New File: `src/main/java/be/lefief/game/turrest01/simulation/strategies/TowerRushStrategy.java`**

```java
package be.lefief.game.turrest01.simulation.strategies;

import be.lefief.game.core.simulation.*;
import be.lefief.game.turrest01.simulation.PlaceTowerAction;
import be.lefief.game.turrest01.tower.TowerDefinition;

import java.util.Comparator;
import java.util.Optional;

/**
 * Simple strategy: Build towers as fast as possible near the creep path.
 */
public class TowerRushStrategy implements Strategy {

    private final TowerDefinition preferredTower;

    public TowerRushStrategy() {
        this(TowerDefinition.BASIC_TOWER);
    }

    public TowerRushStrategy(TowerDefinition preferredTower) {
        this.preferredTower = preferredTower;
    }

    @Override
    public Optional<GameAction> decide(GameStateSnapshot state, int playerNumber) {
        PlayerSnapshot player = state.getPlayer(playerNumber);

        // Check if we can afford a tower
        if (!state.canAfford(playerNumber, preferredTower.getCost())) {
            return Optional.empty();
        }

        // Find best tile near path
        return state.findNearestEmptyTileToPath(playerNumber)
            .map(tile -> new PlaceTowerAction(
                playerNumber,
                tile.x(),
                tile.y(),
                preferredTower.getId()
            ));
    }
}
```

**New File: `src/main/java/be/lefief/game/turrest01/simulation/strategies/EconomyFirstStrategy.java`**

```java
package be.lefief.game.turrest01.simulation.strategies;

import be.lefief.game.core.simulation.*;
import be.lefief.game.turrest01.building.BuildingDefinition;
import be.lefief.game.turrest01.simulation.PlaceBuildingAction;
import be.lefief.game.turrest01.simulation.PlaceTowerAction;
import be.lefief.game.turrest01.tower.TowerDefinition;

import java.util.Optional;

/**
 * Strategy: Build economy buildings first, then towers.
 * Tracks state to follow a build order.
 */
public class EconomyFirstStrategy implements StatefulStrategy {

    private int buildingsPlaced = 0;
    private static final int ECONOMY_PHASE_BUILDINGS = 3;

    @Override
    public void reset() {
        buildingsPlaced = 0;
    }

    @Override
    public Optional<GameAction> decide(GameStateSnapshot state, int playerNumber) {
        PlayerSnapshot player = state.getPlayer(playerNumber);

        // Phase 1: Build economy
        if (buildingsPlaced < ECONOMY_PHASE_BUILDINGS) {
            BuildingDefinition building = chooseBuildingType(state, playerNumber);

            if (state.canAfford(playerNumber, building.getCost())) {
                var tile = findBuildingSpot(state, playerNumber, building);
                if (tile.isPresent()) {
                    buildingsPlaced++;
                    return Optional.of(new PlaceBuildingAction(
                        playerNumber,
                        tile.get().x(),
                        tile.get().y(),
                        building.getId()
                    ));
                }
            }
            return Optional.empty();
        }

        // Phase 2: Build towers
        if (state.canAfford(playerNumber, TowerDefinition.BASIC_TOWER.getCost())) {
            return state.findNearestEmptyTileToPath(playerNumber)
                .map(tile -> new PlaceTowerAction(
                    playerNumber,
                    tile.x(),
                    tile.y(),
                    TowerDefinition.BASIC_TOWER.getId()
                ));
        }

        return Optional.empty();
    }

    private BuildingDefinition chooseBuildingType(GameStateSnapshot state, int playerNumber) {
        // Rotate through building types
        return switch (buildingsPlaced % 3) {
            case 0 -> BuildingDefinition.LUMBERCAMP;
            case 1 -> BuildingDefinition.STONE_QUARRY;
            default -> BuildingDefinition.GOLD_MINE;
        };
    }

    private Optional<TileSnapshot> findBuildingSpot(
            GameStateSnapshot state,
            int playerNumber,
            BuildingDefinition building) {
        return state.getBuildableTiles(playerNumber).stream()
            .filter(t -> building.canBuildOn(t.terrainType()))
            .findFirst();
    }
}
```

#### 4.3 Strategy Tester

**New File: `src/main/java/be/lefief/game/core/simulation/StrategyTester.java`**

```java
package be.lefief.game.core.simulation;

import java.util.Map;
import java.util.concurrent.*;
import java.util.function.Supplier;

/**
 * Framework for comparing strategies across multiple games.
 * Supports parallel execution for faster results.
 */
public class StrategyTester<G extends SimulatableGame> {

    private final Supplier<G> gameFactory;
    private final double tickDurationSeconds;
    private final double maxGameDurationSeconds;

    public StrategyTester(
            Supplier<G> gameFactory,
            double tickDurationSeconds,
            double maxGameDurationSeconds) {
        this.gameFactory = gameFactory;
        this.tickDurationSeconds = tickDurationSeconds;
        this.maxGameDurationSeconds = maxGameDurationSeconds;
    }

    /**
     * Compare two strategies over multiple games.
     */
    public StrategyComparisonResult compare(
            Strategy strategyA,
            Strategy strategyB,
            int numberOfGames) {
        return compare(strategyA, strategyB, numberOfGames, 1);
    }

    /**
     * Compare two strategies with parallel execution.
     */
    public StrategyComparisonResult compare(
            Strategy strategyA,
            Strategy strategyB,
            int numberOfGames,
            int parallelism) {

        ExecutorService executor = Executors.newFixedThreadPool(parallelism);
        int winsA = 0, winsB = 0, draws = 0;

        try {
            var futures = new java.util.ArrayList<Future<SimulationResult>>();

            for (int i = 0; i < numberOfGames; i++) {
                final int gameIndex = i;
                futures.add(executor.submit(() -> runMatch(
                    // Alternate who plays as player 0 for fairness
                    gameIndex % 2 == 0 ? strategyA : strategyB,
                    gameIndex % 2 == 0 ? strategyB : strategyA
                )));
            }

            for (int i = 0; i < futures.size(); i++) {
                SimulationResult result = futures.get(i).get();
                boolean aIsPlayer0 = (i % 2 == 0);

                if (result.isDraw()) {
                    draws++;
                } else if (result.playerWon(0)) {
                    if (aIsPlayer0) winsA++; else winsB++;
                } else {
                    if (aIsPlayer0) winsB++; else winsA++;
                }
            }
        } catch (Exception e) {
            throw new RuntimeException("Strategy comparison failed", e);
        } finally {
            executor.shutdown();
        }

        return new StrategyComparisonResult(winsA, winsB, draws);
    }

    private SimulationResult runMatch(Strategy player0Strategy, Strategy player1Strategy) {
        // Reset stateful strategies
        if (player0Strategy instanceof StatefulStrategy s) s.reset();
        if (player1Strategy instanceof StatefulStrategy s) s.reset();

        GameSimulator<G> sim = GameSimulator.create(gameFactory, tickDurationSeconds);
        sim.setStrategy(0, player0Strategy);
        sim.setStrategy(1, player1Strategy);

        SimulationResult result = sim.run(maxGameDurationSeconds);

        // Notify strategies of game end
        if (player0Strategy instanceof StatefulStrategy s) s.onGameEnd(result);
        if (player1Strategy instanceof StatefulStrategy s) s.onGameEnd(result);

        return result;
    }
}

/**
 * Results of strategy comparison.
 */
public record StrategyComparisonResult(
    int winsA,
    int winsB,
    int draws
) {
    public int totalGames() {
        return winsA + winsB + draws;
    }

    public double winRateA() {
        return totalGames() == 0 ? 0 : (double) winsA / totalGames();
    }

    public double winRateB() {
        return totalGames() == 0 ? 0 : (double) winsB / totalGames();
    }

    @Override
    public String toString() {
        return String.format(
            "A: %d wins (%.1f%%), B: %d wins (%.1f%%), Draws: %d",
            winsA, winRateA() * 100,
            winsB, winRateB() * 100,
            draws
        );
    }
}
```

---

### Part 5: TurrestGameMode01 Simulation Support

#### 5.1 Implement SimulatableGame

**Modify: `TurrestGameMode01.java`**

```java
public class TurrestGameMode01 extends Game<Turrest01Player>
        implements SimulatableGame {

    // ... existing fields ...

    private double gameTimeSeconds = 0;

    // ========== SimulatableGame Implementation ==========

    @Override
    public void processTick(double deltaTimeSeconds) {
        gameTimeSeconds += deltaTimeSeconds;

        if (creepManager != null) {
            creepManager.tick(tickCount, this, deltaTimeSeconds);
        }
        if (towerManager != null) {
            towerManager.tick(this);
        }

        // Resource production every 5 ticks
        if (tickCount % RESOURCE_UPDATE_INTERVAL == 0) {
            for (Turrest01Player player : getPlayerByNumber().values()) {
                if (player.isAlive()) {
                    player.getResources().addProduction();
                }
            }
        }

        tickCount++;

        // Check singleplayer victory
        if (singleplayer) {
            checkSingleplayerVictory();
        }
    }

    @Override
    public double getGameTimeSeconds() {
        return gameTimeSeconds;
    }

    @Override
    public boolean isRunning() {
        return isGameIsRunning();
    }

    @Override
    public GameStateSnapshot createSnapshot() {
        return new TurrestGameStateSnapshot(this);
    }

    @Override
    public ActionResult executeAction(GameAction action) {
        if (!(action instanceof TurrestAction turrestAction)) {
            return ActionResult.failure("Unknown action type");
        }

        return switch (turrestAction) {
            case PlaceBuildingAction a -> executePlaceBuilding(a);
            case PlaceTowerAction a -> executePlaceTower(a);
            case SendCreepAction a -> executeSendCreep(a);
        };
    }

    private ActionResult executePlaceBuilding(PlaceBuildingAction action) {
        Turrest01Player player = getPlayerByNumber().get(action.playerNumber());
        if (player == null) return ActionResult.failure("Player not found");

        BuildingDefinition def = BuildingDefinition.fromId(action.buildingTypeId());
        if (def == null) return ActionResult.failure("Unknown building type");

        Tile tile = gameMap.getTile(action.x(), action.y());
        if (tile == null) return ActionResult.failure("Invalid position");
        if (!tile.canPlayerBuild(player.getPlayerNumber()))
            return ActionResult.failure("Cannot build here");
        if (tile.hasStructure()) return ActionResult.failure("Tile occupied");
        if (!player.getResources().canAfford(def.getCost()))
            return ActionResult.failure("Cannot afford");

        player.getResources().subtract(def.getCost());
        player.getResources().addProductionBonuses(def.getProductionBonus());
        tile.setStructure(new TurrestBuilding(def, player.getPlayerNumber()));

        return ActionResult.success();
    }

    private ActionResult executePlaceTower(PlaceTowerAction action) {
        // Similar validation and execution...
        Turrest01Player player = getPlayerByNumber().get(action.playerNumber());
        if (player == null) return ActionResult.failure("Player not found");

        TowerDefinition def = TowerDefinition.fromId(action.towerTypeId());
        if (def == null) return ActionResult.failure("Unknown tower type");

        Tile tile = gameMap.getTile(action.x(), action.y());
        if (tile == null) return ActionResult.failure("Invalid position");
        if (!tile.canPlayerBuild(player.getPlayerNumber()))
            return ActionResult.failure("Cannot build here");
        if (tile.hasStructure()) return ActionResult.failure("Tile occupied");
        if (!player.getResources().canAfford(def.getCost()))
            return ActionResult.failure("Cannot afford");

        player.getResources().subtract(def.getCost());
        Tower tower = createTower(def, player.getPlayerNumber(), action.x(), action.y());
        towerManager.addTower(tower);

        return ActionResult.success();
    }

    private ActionResult executeSendCreep(SendCreepAction action) {
        if (singleplayer) return ActionResult.failure("No opponents in singleplayer");

        Turrest01Player player = getPlayerByNumber().get(action.playerNumber());
        if (player == null) return ActionResult.failure("Player not found");

        CreepType type = CreepType.fromId(action.creepTypeId());
        if (type == null) return ActionResult.failure("Unknown creep type");

        if (!type.getSendCost().canAfford(player))
            return ActionResult.failure("Cannot afford");

        type.getSendCost().apply(player);
        creepManager.spawnSentCreep(type, player.getPlayerNumber(), this);

        return ActionResult.success();
    }
}
```

#### 5.2 Game State Snapshot Implementation

**New File: `src/main/java/be/lefief/game/turrest01/simulation/TurrestGameStateSnapshot.java`**

```java
package be.lefief.game.turrest01.simulation;

import be.lefief.game.core.simulation.*;
import be.lefief.game.turrest01.*;
import be.lefief.game.turrest01.creep.Creep;
import be.lefief.game.turrest01.tower.Tower;

import java.util.*;

/**
 * Immutable snapshot of Turrest game state.
 */
public class TurrestGameStateSnapshot implements GameStateSnapshot {

    private final double gameTimeSeconds;
    private final int currentTick;
    private final int mapWidth;
    private final int mapHeight;
    private final List<PlayerSnapshot> players;
    private final List<CreepSnapshot> creeps;
    private final List<TowerSnapshot> towers;
    private final TileSnapshot[][] tiles;

    public TurrestGameStateSnapshot(TurrestGameMode01 game) {
        this.gameTimeSeconds = game.getGameTimeSeconds();
        this.currentTick = game.getTickCount();
        this.mapWidth = game.getGameMap().getWidth();
        this.mapHeight = game.getGameMap().getHeight();

        // Snapshot players
        this.players = game.getPlayerByNumber().values().stream()
            .map(p -> new PlayerSnapshot(
                p.getPlayerNumber(),
                p.getColorIndex(),
                p.isAlive(),
                p.getHitpoints(),
                p.getResources().getGold(),
                p.getResources().getWood(),
                p.getResources().getStone(),
                p.getScore()
            ))
            .toList();

        // Snapshot creeps
        this.creeps = game.getCreepManager().getAllCreeps().stream()
            .map(c -> new CreepSnapshot(
                c.getId(),
                c.getType().getId(),
                c.getSenderPlayerNumber(),
                c.getTargetPlayerNumber(),
                c.getX(),
                c.getY(),
                c.getHitpoints(),
                c.getType().getHitpoints()
            ))
            .toList();

        // Snapshot towers
        this.towers = game.getTowerManager().getAllTowers().stream()
            .map(t -> new TowerSnapshot(
                t.getId(),
                t.getDefinition().getId(),
                t.getPlayerNumber(),
                t.getX(),
                t.getY(),
                t.getDefinition().getRange(),
                t.getDefinition().getDamage()
            ))
            .toList();

        // Snapshot tiles
        this.tiles = new TileSnapshot[mapWidth][mapHeight];
        for (int x = 0; x < mapWidth; x++) {
            for (int y = 0; y < mapHeight; y++) {
                var tile = game.getGameMap().getTile(x, y);
                tiles[x][y] = new TileSnapshot(
                    x, y,
                    tile.getTerrainType().name(),
                    tile.hasStructure(),
                    tile.hasStructure() ? tile.getStructure().getType().name() : null,
                    tile.getOwners().isEmpty() ? -1 : tile.getOwners().iterator().next()
                );
            }
        }
    }

    @Override
    public double getGameTimeSeconds() { return gameTimeSeconds; }

    @Override
    public int getCurrentTick() { return currentTick; }

    @Override
    public int getPlayerCount() { return players.size(); }

    @Override
    public PlayerSnapshot getPlayer(int playerNumber) {
        return players.stream()
            .filter(p -> p.playerNumber() == playerNumber)
            .findFirst()
            .orElse(null);
    }

    @Override
    public List<PlayerSnapshot> getAllPlayers() {
        return players;
    }

    @Override
    public int getMapWidth() { return mapWidth; }

    @Override
    public int getMapHeight() { return mapHeight; }

    @Override
    public TileSnapshot getTile(int x, int y) {
        if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) return null;
        return tiles[x][y];
    }

    @Override
    public List<CreepSnapshot> getCreeps() { return creeps; }

    @Override
    public List<CreepSnapshot> getCreepsForPlayer(int playerNumber) {
        return creeps.stream()
            .filter(c -> c.targetPlayerNumber() == playerNumber)
            .toList();
    }

    @Override
    public List<TowerSnapshot> getTowers() { return towers; }

    @Override
    public List<TowerSnapshot> getTowersForPlayer(int playerNumber) {
        return towers.stream()
            .filter(t -> t.ownerPlayerNumber() == playerNumber)
            .toList();
    }

    @Override
    public boolean canAfford(int playerNumber, ResourceCost cost) {
        PlayerSnapshot player = getPlayer(playerNumber);
        if (player == null) return false;
        return player.gold() >= cost.getGold()
            && player.wood() >= cost.getWood()
            && player.stone() >= cost.getStone();
    }

    @Override
    public List<TileSnapshot> getBuildableTiles(int playerNumber) {
        List<TileSnapshot> result = new ArrayList<>();
        for (int x = 0; x < mapWidth; x++) {
            for (int y = 0; y < mapHeight; y++) {
                TileSnapshot tile = tiles[x][y];
                if (!tile.hasStructure() && tile.ownerPlayerNumber() == playerNumber) {
                    result.add(tile);
                }
            }
        }
        return result;
    }

    @Override
    public Optional<TileSnapshot> findNearestEmptyTileToPath(int playerNumber) {
        // Implementation depends on path data - simplified version
        return getBuildableTiles(playerNumber).stream()
            .filter(t -> "GRASS".equals(t.terrainType()))
            .findFirst();
    }
}
```

---

### Part 6: Files to Create/Modify

#### Core Simulation Framework (Reusable)

| File | Action | Purpose |
|------|--------|---------|
| `SimulatableGame.java` | CREATE | Interface for simulatable games |
| `GameStateSnapshot.java` | CREATE | Immutable state snapshot interfaces |
| `GameAction.java` | CREATE | Command pattern for actions |
| `ActionResult.java` | CREATE | Action execution result |
| `GameSimulator.java` | CREATE | Time-based simulation engine |
| `SimulationResult.java` | CREATE | Simulation run results |
| `Strategy.java` | CREATE | Strategy interface |
| `StatefulStrategy.java` | CREATE | Strategy with memory |
| `StrategyTester.java` | CREATE | Strategy comparison framework |
| `StrategyComparisonResult.java` | CREATE | Comparison results |

#### Turrest-Specific

| File | Action | Purpose |
|------|--------|---------|
| `TurrestActions.java` | CREATE | Turrest action records |
| `TurrestGameStateSnapshot.java` | CREATE | Turrest snapshot implementation |
| `TowerRushStrategy.java` | CREATE | Example strategy |
| `EconomyFirstStrategy.java` | CREATE | Example strategy with state |
| `TurrestGameMode01.java` | MODIFY | Implement SimulatableGame |
| `CreepManager.java` | MODIFY | Add getAllCreeps() method |
| `TowerManager.java` | MODIFY | Add getAllTowers() method |

#### Singleplayer

| File | Action | Purpose |
|------|--------|---------|
| `StartSingleplayerCommand.java` | CREATE | Command for singleplayer |
| `StartSingleplayerHandler.java` | CREATE | Handle singleplayer request |
| `StartSingleplayerListener.java` | CREATE | Listen for command |
| `GameService.java` | MODIFY | Add createSingleplayerGame() |
| `lobby-list.component.ts` | MODIFY | Add "Play Solo" button |
| `lobby.service.ts` | MODIFY | Add startSingleplayerGame() |

---

### Part 7: Implementation Order

1. **Singleplayer Backend** (1 hr)
   - Create StartSingleplayerCommand and handler
   - Add createSingleplayerGame() to GameService
   - Add singleplayer flag to TurrestGameMode01
   - Implement singleplayer victory condition

2. **Singleplayer Frontend** (30 min)
   - Add "Play Solo" button to lobby-list
   - Add startSingleplayerGame() to lobby.service
   - Test singleplayer game flow

3. **Core Simulation Interfaces** (1 hr)
   - Create SimulatableGame interface
   - Create GameStateSnapshot interfaces
   - Create GameAction and ActionResult

4. **GameSimulator** (1 hr)
   - Implement time-based GameSimulator
   - Implement action scheduling
   - Implement strategy integration

5. **TurrestGameMode01 Integration** (2 hr)
   - Implement SimulatableGame interface
   - Implement executeAction() for all actions
   - Create TurrestGameStateSnapshot
   - Add getAllCreeps()/getAllTowers() to managers

6. **Strategy Framework** (1 hr)
   - Create Strategy interface
   - Create StrategyTester
   - Implement TowerRushStrategy
   - Implement EconomyFirstStrategy

7. **Testing & Benchmarks** (1 hr)
   - Write unit tests for simulation
   - Benchmark simulation speed
   - Test strategy comparison

---

### Key Improvements Summary

| Issue | Before | After |
|-------|--------|-------|
| Simulation pollutes production code | `simulationMode` flag in game | `SimulatableGame` interface |
| Tick-based scheduling | `scheduleAction(tick, ...)` | `scheduleAction(seconds, ...)` |
| Mutable state for strategies | Direct game access | `GameStateSnapshot` (immutable) |
| Tight coupling | `new TurrestGameMode01()` in simulator | Factory/supplier pattern |
| Action list return | `List<GameAction>` | `Optional<GameAction>` |
| No determinism | Random varies per run | Support for seeded RNG |
| Game-specific simulator | `TurrestGameSimulator` | Generic `GameSimulator<G>` |
| Sequential strategy testing | One game at a time | Parallel execution support |

---

### Example Usage

**Running a fast simulation:**

```java
// Create simulator with game factory
var simulator = GameSimulator.create(
    () -> TurrestGameMode01.createForSimulation(SimulationConfig.singlePlayer()),
    0.2  // 200ms tick duration in seconds
);

// Schedule actions by game time (seconds)
simulator.scheduleAction(10.0, new PlaceTowerAction(0, 5, 5, TowerDefinition.BASIC_TOWER.getId()));
simulator.scheduleAction(20.0, new PlaceTowerAction(0, 6, 5, TowerDefinition.BASIC_TOWER.getId()));

// Run for 5 minutes of game time
SimulationResult result = simulator.run(300.0);

System.out.printf("Simulated %.1f seconds in %.1f ms (%.0fx speed)%n",
    result.gameTimeSeconds(),
    result.realTimeMs(),
    result.getSpeedMultiplier());
```

**Comparing strategies:**

```java
var tester = new StrategyTester<>(
    () -> TurrestGameMode01.createForSimulation(SimulationConfig.versus()),
    0.2,   // tick duration
    600.0  // max 10 minutes per game
);

var aggressive = new TowerRushStrategy();
var defensive = new EconomyFirstStrategy();

// Run 100 games with 4 threads
var result = tester.compare(aggressive, defensive, 100, 4);

System.out.println(result);
// Output: "A: 45 wins (45.0%), B: 52 wins (52.0%), Draws: 3"
```

---

### Testing Checklist

**Singleplayer:**
- [ ] "Play Solo" button appears on lobby list
- [ ] Clicking starts game immediately (no lobby wait)
- [ ] Player receives waves as normal
- [ ] SendCreeps panel is hidden or disabled in singleplayer
- [ ] Surviving all waves shows victory screen
- [ ] Death shows game over screen

**Simulation:**
- [ ] SimulatableGame interface correctly abstracts simulation
- [ ] GameSimulator works with time-based scheduling
- [ ] GameStateSnapshot is truly immutable
- [ ] Actions execute correctly via executeAction()
- [ ] Simulation completes 1000 ticks in <100ms

**Strategy Testing:**
- [ ] Strategies receive immutable state snapshots
- [ ] Optional<GameAction> pattern works correctly
- [ ] StatefulStrategy.reset() called between games
- [ ] Parallel strategy comparison works
- [ ] Results are reproducible with same seed

