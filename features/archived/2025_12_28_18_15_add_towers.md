Instructions: 

We're going to add a new concept: Towers. This is entirely within the turrest01 game.
Towers are a type of building; there will be multiple kinds of towers. 

Tower (general): 
- shootingRange: how far the tower can shoot 
- fireRate: how fast the turret fires bullets 
- bulletDamage: how much damage each bullet does on hit 
- bulletType: indicator which sprite to use for bullets 
- woodCost: cost to place (wood)
- stoneCost: cost to place (stone)
- goldCost: cost to place (gold)

We're going to add a BasicTower first (extending Tower) 

- shootingRange: about 3 tiles far - but express it in radius, so we can configure it independently of tile size 
- fireRate: 1 bullet per second 
- bulletDamage: 10 
- bulletType: BASIC 
- woodCost: 80
- stoneCost: 80
- goldCost: 100

Towers start shooting automatically when placed, by a "FURTHEST" strategy: shoot at the creep that is closest to the castle, but within firing range. 
If no creeps in firing range, the tower doesnt shoot. 
After a shot, the turret virtually goes in cooldown mode until it can fire again. (c.f.r. fireRate)

add basic tower sprite and basic bullet sprite to support this visually

---

# Implementation Plan

## Architecture Overview

Towers will extend the existing building system with combat capabilities. A new `TowerManager` class will handle targeting and shooting logic, integrated into the game tick loop.

```
Game Tick (200ms / 5Hz)
    â†“
CreepManager.tick() â†’ moves creeps, updates positions
    â†“
TowerManager.tick() â†’ finds targets, fires, damages creeps
    â†“
BatchedTowerAttackCommand â†’ frontend renders bullets
```

---

## Phase 1: Backend Tower Foundation

### 1.1 Create Tower Base Class

Location: `src/main/java/be/lefief/game/turrest01/tower/Tower.java`

```java
public abstract class Tower {
    private final UUID id;
    private final int ownerPlayerNumber;
    private final int tileX, tileY;
    private int cooldownTicksRemaining; // ticks until next shot

    // Abstract methods for tower types
    public abstract double getShootingRange();    // in tiles
    public abstract int getCooldownMs();          // cooldown in milliseconds
    public abstract int getBulletDamage();
    public abstract String getBulletType();
    public abstract int getWoodCost();
    public abstract int getStoneCost();
    public abstract int getGoldCost();

    // Practical cooldown respecting tick rate (rounded up)
    public int getCooldownTicks(int tickRateMs) {
        return Math.max(1, (int) Math.ceil((double) getCooldownMs() / tickRateMs));
    }

    // Theoretical fire rate (shots per second)
    public double getTheoreticalFireRate() {
        return 1000.0 / getCooldownMs();
    }

    // Practical fire rate respecting tick rate
    public double getPracticalFireRate(int tickRateMs) {
        int cooldownTicks = getCooldownTicks(tickRateMs);
        return 1000.0 / (cooldownTicks * tickRateMs);
    }

    public boolean canFire() { return cooldownTicksRemaining <= 0; }
    public void fire(int tickRateMs) { cooldownTicksRemaining = getCooldownTicks(tickRateMs); }
    public void tickCooldown() { cooldownTicksRemaining = Math.max(0, cooldownTicksRemaining - 1); }
}
```

**Cooldown/Tickrate Example:**
- BasicTower: `cooldownMs = 1000` (theoretical 1.0 shots/sec)
- With `TICK_RATE_MS = 200`: cooldownTicks = ceil(1000/200) = 5 ticks
- Practical fire rate: 1000 / (5 * 200) = 1.0 shots/sec âœ“

- FastTower: `cooldownMs = 300` (theoretical 3.33 shots/sec)
- With `TICK_RATE_MS = 200`: cooldownTicks = ceil(300/200) = 2 ticks
- Practical fire rate: 1000 / (2 * 200) = 2.5 shots/sec (rounded down from 3.33)

### 1.2 Create BasicTower

Location: `src/main/java/be/lefief/game/turrest01/tower/BasicTower.java`

```java
public class BasicTower extends Tower {
    public double getShootingRange() { return 3.0; }  // 3 tiles radius
    public int getCooldownMs() { return 1000; }       // 1000ms = 1 shot/sec theoretical
    public int getBulletDamage() { return 10; }
    public String getBulletType() { return "BASIC"; }
    public int getWoodCost() { return 80; }
    public int getStoneCost() { return 80; }
    public int getGoldCost() { return 100; }
}
// At 200ms tick rate: practical fire rate = 1.0 shots/sec (5 ticks cooldown)
```

### 1.3 Create TowerManager

Location: `src/main/java/be/lefief/game/turrest01/tower/TowerManager.java`

```java
public class TowerManager {
    private final Map<UUID, Tower> towers = new ConcurrentHashMap<>();
    private final CreepManager creepManager;
    private final int tickRateMs;

    public TowerManager(CreepManager creepManager, int tickRateMs) {
        this.creepManager = creepManager;
        this.tickRateMs = tickRateMs;
    }

    public void tick(TurrestGameMode01 game) {
        List<TowerAttack> attacks = new ArrayList<>();

        for (Tower tower : towers.values()) {
            tower.tickCooldown();  // Decrement cooldown by 1 tick

            if (tower.canFire()) {
                Creep target = findTarget(tower);
                if (target != null) {
                    tower.fire(tickRateMs);  // Reset cooldown based on tick rate
                    target.takeDamage(tower.getBulletDamage());
                    attacks.add(new TowerAttack(tower, target));
                }
            }
        }

        // Batch all attacks into single command
        if (!attacks.isEmpty()) {
            game.broadcastToAllPlayers(new BatchedTowerAttackCommand(attacks));
        }
    }

    // FURTHEST strategy: creep closest to castle (highest path index) within range
    private Creep findTarget(Tower tower) {
        return creepManager.getActiveCreeps().stream()
            .filter(c -> !c.isDead() && c.getOwnerPlayerNumber() == tower.getOwnerPlayerNumber())
            .filter(c -> isInRange(tower, c))
            .max(Comparator.comparingInt(Creep::getCurrentPathIndex))
            .orElse(null);
    }

    private boolean isInRange(Tower tower, Creep creep) {
        double dx = tower.getCenterX() - creep.getX();
        double dy = tower.getCenterY() - creep.getY();
        double distance = Math.sqrt(dx*dx + dy*dy);
        return distance <= tower.getShootingRange();
    }
}
```

### 1.4 Add TowerDefinition Enum

Location: `src/main/java/be/lefief/game/turrest01/tower/TowerDefinition.java`

```java
public enum TowerDefinition {
    BASIC_TOWER(1, "Basic Tower", 3.0, 1000, 10, "BASIC",
                new ResourceCost(80, 80, 100),
                List.of(TerrainType.GRASS, TerrainType.DIRT));

    private final int id;
    private final String name;
    private final double shootingRange;    // tiles
    private final int cooldownMs;          // milliseconds between shots
    private final int bulletDamage;
    private final String bulletType;
    private final ResourceCost cost;
    private final List<TerrainType> allowedTerrains;

    // Helper methods
    public double getTheoreticalFireRate() { return 1000.0 / cooldownMs; }
    public double getPracticalFireRate(int tickRateMs) {
        int cooldownTicks = (int) Math.ceil((double) cooldownMs / tickRateMs);
        return 1000.0 / (cooldownTicks * tickRateMs);
    }
}
```

---

## Phase 2: Backend Integration

### 2.1 Update TurrestGameMode01

Location: `TurrestGameMode01.java`

```java
// Add field
private TowerManager towerManager;

// In start() after creepManager creation
towerManager = new TowerManager(creepManager);

// In gameTick() after creepManager.tick()
if (towerManager != null) {
    towerManager.tick(TICK_DURATION_SEC, this);
}
```

### 2.2 Create Tower Placement Handler

Location: `src/main/java/be/lefief/game/turrest01/handlers/Turrest01GameHandler.java`

Add method:
```java
public void handlePlaceTower(Turrest01Player player, int x, int y, int towerType) {
    // Validate placement (terrain, ownership, resources)
    // Deduct resources
    // Create Tower instance
    // Register with TowerManager
    // Send TowerPlacedCommand to all players
}
```

### 2.3 Create Commands

Location: `src/main/java/be/lefief/game/turrest01/commands/`

**TowerPlacedCommand.java:**
```java
Topic: "TOWER_PLACED"
Data: { towerId, towerType, x, y, playerNumber, range }
```

**BatchedTowerAttackCommand.java:**
```java
Topic: "BATCHED_TOWER_ATTACK"
Data: {
    attacks: [
        {
            towerId: UUID,
            towerX: double, towerY: double,
            targetCreepId: UUID,
            targetX: double, targetY: double,
            damage: int,
            bulletType: String
        }
    ]
}
```

---

## Phase 3: Frontend Tower Support

### 3.1 Update Game Models

Location: `frontend/src/app/shared/models/game.model.ts`

```typescript
export interface TowerDefinition {
    id: number;
    name: string;
    icon: string;
    cost: { wood: number; stone: number; gold: number };
    allowedTerrains: TerrainType[];
    range: number;
    fireRate: number;
    damage: number;
}

export const TOWER_DEFINITIONS: TowerDefinition[] = [
    {
        id: 1,
        name: 'Basic Tower',
        icon: 'ðŸ—¼',
        cost: { wood: 80, stone: 80, gold: 100 },
        allowedTerrains: [TerrainType.GRASS, TerrainType.DIRT],
        range: 3,
        fireRate: 1,
        damage: 10
    }
];

export interface Tower {
    id: string;
    towerType: number;
    x: number;
    y: number;
    playerNumber: number;
    range: number;
}

export interface TowerAttack {
    towerId: string;
    towerX: number;
    towerY: number;
    targetCreepId: string;
    targetX: number;
    targetY: number;
    damage: number;
    bulletType: string;
    progress: number; // 0-1 for animation
}
```

### 3.2 Update GameComponent

Location: `frontend/src/app/features/game/game.component.ts`

**Add State:**
```typescript
towers: Map<string, Tower> = new Map();
activeAttacks: TowerAttack[] = [];
```

**Add Handlers:**
```typescript
// Listen for tower placed
const towerPlacedSub = this.socketService.onCommand('GAME', 'TOWER_PLACED')
    .subscribe(cmd => this.handleTowerPlaced(cmd.data));

// Listen for tower attacks
const towerAttackSub = this.socketService.onCommand('GAME', 'BATCHED_TOWER_ATTACK')
    .subscribe(cmd => this.handleTowerAttacks(cmd.data));

private handleTowerPlaced(data: Record<string, any>): void {
    const tower: Tower = {
        id: data['towerId'],
        towerType: data['towerType'],
        x: data['x'],
        y: data['y'],
        playerNumber: data['playerNumber'],
        range: data['range']
    };
    this.towers.set(tower.id, tower);
}

private handleTowerAttacks(data: Record<string, any>): void {
    const attacks = data['attacks'] as Array<Record<string, any>>;
    for (const attack of attacks) {
        this.activeAttacks.push({
            towerId: attack['towerId'],
            towerX: attack['towerX'],
            towerY: attack['towerY'],
            targetCreepId: attack['targetCreepId'],
            targetX: attack['targetX'],
            targetY: attack['targetY'],
            damage: attack['damage'],
            bulletType: attack['bulletType'],
            progress: 0
        });
    }
}
```

### 3.3 Render Towers and Bullets

**In render() method:**
```typescript
// Draw towers
this.drawTowers();

// Draw active bullet animations
this.drawBullets();
```

**New methods:**
```typescript
private drawTowers(): void {
    for (const tower of this.towers.values()) {
        const screenX = tower.x * this.tileSize - this.cameraX;
        const screenY = tower.y * this.tileSize - this.cameraY;

        // Draw tower base
        this.ctx.fillStyle = '#555';
        this.ctx.fillRect(screenX + 4, screenY + 4, this.tileSize - 8, this.tileSize - 8);

        // Draw tower icon
        this.ctx.font = `${this.tileSize * 0.6}px Arial`;
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillStyle = '#fff';
        this.ctx.fillText('ðŸ—¼', screenX + this.tileSize/2, screenY + this.tileSize/2);

        // Optional: Draw range circle when selected
    }
}

private drawBullets(): void {
    for (const attack of this.activeAttacks) {
        const startX = attack.towerX * this.tileSize - this.cameraX;
        const startY = attack.towerY * this.tileSize - this.cameraY;
        const endX = attack.targetX * this.tileSize - this.cameraX;
        const endY = attack.targetY * this.tileSize - this.cameraY;

        // Interpolate bullet position
        const bulletX = startX + (endX - startX) * attack.progress;
        const bulletY = startY + (endY - startY) * attack.progress;

        // Draw bullet
        this.ctx.beginPath();
        this.ctx.arc(bulletX, bulletY, 4, 0, Math.PI * 2);
        this.ctx.fillStyle = '#ff0';
        this.ctx.fill();
    }
}
```

**In updateCreepPositions() or animation loop:**
```typescript
// Update bullet animations
this.activeAttacks = this.activeAttacks.filter(attack => {
    attack.progress += deltaTime * 5; // Complete in 0.2 seconds
    return attack.progress < 1;
});
```

### 3.4 Update ActionPanel for Tower Placement

Add tower buttons alongside building buttons with same placement flow.

---

## Phase 4: Assets

### 4.1 Tower Sprite

Location: `frontend/src/assets/sprites/towers/basic_tower.png`

- Size: 32x32 pixels
- Style: Simple tower silhouette matching game aesthetic

### 4.2 Bullet Sprite

Location: `frontend/src/assets/sprites/bullets/basic.png`

- Size: 8x8 or 16x16 pixels
- Style: Yellow/orange projectile

---

## Implementation Order

| Phase | Task | Files | Effort |
|-------|------|-------|--------|
| 1.1 | Tower base class | `Tower.java` | 30 min |
| 1.2 | BasicTower | `BasicTower.java` | 15 min |
| 1.3 | TowerManager | `TowerManager.java` | 1 hour |
| 1.4 | TowerDefinition enum | `TowerDefinition.java` | 15 min |
| 2.1 | Integrate into game loop | `TurrestGameMode01.java` | 15 min |
| 2.2 | Placement handler | `Turrest01GameHandler.java` | 45 min |
| 2.3 | Commands | `TowerPlacedCommand.java`, `BatchedTowerAttackCommand.java` | 30 min |
| 3.1 | Frontend models | `game.model.ts` | 15 min |
| 3.2 | GameComponent handlers | `game.component.ts` | 30 min |
| 3.3 | Rendering | `game.component.ts` | 45 min |
| 3.4 | ActionPanel updates | `action-panel.component.ts` | 30 min |
| 4.1-4.2 | Assets | PNG files | 15 min |

**Total: ~5-6 hours**

---

## Key Considerations

1. **Targeting "FURTHEST" Strategy**: Creep with highest `currentPathIndex` within range
2. **Tower Ownership**: Towers only target creeps on their owner's map section
3. **Cooldown Tracking**: Per-tower cooldown in seconds, decremented each tick
4. **Bullet Animation**: Client-side interpolation over ~200ms for smooth visuals
5. **Performance**: Batch all tower attacks into single command per tick
6. **Creep Death**: When creep HP <= 0, mark as dead; CreepManager handles removal

---

## Future Extensions

- Multiple tower types (splash damage, slow, chain lightning)
- Tower upgrades
- Tower selling/removal
- Range indicators on hover
- Tower rotation toward target

